<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3dtiles-polygon-crop</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.113/Build/Cesium/Cesium.js"></script>
    <link
      rel="stylesheet"
      href="https://cesium.com/downloads/cesiumjs/releases/1.113/Build/Cesium/Widgets/widgets.css"
    />
    <style>
      body {
        margin: 0;
      }

      #cesiumContainer {
        height: 100vh;
      }
    </style>
  </head>
  <body>
    <div id="cesiumContainer"></div>

    <script type="module">
      import { tileSetClipByPolygon } from "./index.js";

      Cesium.Ion.defaultAccessToken =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJkNzEwOTRhMi05YmYyLTQyY2EtYTU2My04YTM1MWE2YjhjNjAiLCJpZCI6MjU5LCJpYXQiOjE3MDQyMTcxMzh9.rE7KTaFyZydhuP1Z7ohzClO3J1tMOvaHODzt3_5jo7s";

      let points = [];
      let activeShape;
      let floatingPoint;
      let drawingMode = "line";
      let activeShapePoints = [];
      const viewer = new Cesium.Viewer("cesiumContainer", {
        infoBox: false,
        selectionIndicator: false,
        terrain: Cesium.Terrain.fromWorldTerrain(),
      });
      const tileset = await Cesium.Cesium3DTileset.fromUrl(
        "http://lab.earthsdk.com/model/66327820ce5f11eab7a4adf1d6568ff7/tileset.json"
      );
      // 贴地(设置模型高度)
      const translation = Cesium.Cartesian3.fromArray([0, 0, -50]);
      tileset.modelMatrix = Cesium.Matrix4.fromTranslation(translation);
      viewer.scene.primitives.add(tileset);
      viewer.zoomTo(tileset);
      function createPoint(worldPosition) {
        const point = viewer.entities.add({
          position: worldPosition,
          point: {
            pixelSize: 5,
            color: Cesium.Color.WHITE,
            heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
          },
        });
        return point;
      }

      function drawShape(positionData) {
        let shape;
        if (drawingMode === "line") {
          shape = viewer.entities.add({
            polyline: {
              positions: positionData,
              clampToGround: true,
              width: 3,
            },
          });
        } else if (drawingMode === "polygon") {
          shape = viewer.entities.add({
            polygon: {
              hierarchy: positionData,
              material: new Cesium.ColorMaterialProperty(Cesium.Color.WHITE.withAlpha(0.7)),
            },
          });
        }
        return shape;
      }

      const handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);

      function terminateShape() {
        activeShapePoints.pop();
        drawShape(activeShapePoints);
        viewer.entities.remove(floatingPoint);
        viewer.entities.remove(activeShape);
        floatingPoint = undefined;
        activeShape = undefined;
        activeShapePoints = [];
      }

      handler.setInputAction((event) => {
        const ray = viewer.camera.getPickRay(event.position);
        const earthPosition = viewer.scene.globe.pick(ray, viewer.scene);

        if (Cesium.defined(earthPosition)) {
          if (activeShapePoints.length === 0) {
            floatingPoint = createPoint(earthPosition);
            activeShapePoints.push(earthPosition);
            const dynamicPositions = new Cesium.CallbackProperty(function () {
              if (drawingMode === "polygon") {
                return new Cesium.PolygonHierarchy(activeShapePoints);
              }
              return activeShapePoints;
            }, false);
            activeShape = drawShape(dynamicPositions);
          }
          activeShapePoints.push(earthPosition);
          createPoint(earthPosition);
        }
        // 将笛卡尔坐标转换为经纬度;
        const position = viewer.camera.pickEllipsoid(event.position);
        const cartographic = Cesium.Cartographic.fromCartesian(position);
        const longitude = Cesium.Math.toDegrees(cartographic.longitude);
        const latitude = Cesium.Math.toDegrees(cartographic.latitude);

        points.push([longitude, latitude]);
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

      handler.setInputAction((event) => {
        if (Cesium.defined(floatingPoint)) {
          const ray = viewer.camera.getPickRay(event.endPosition);
          const newPosition = viewer.scene.globe.pick(ray, viewer.scene);
          if (Cesium.defined(newPosition)) {
            floatingPoint.position.setValue(newPosition);
            activeShapePoints.pop();
            activeShapePoints.push(newPosition);
          }
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

      handler.setInputAction((event) => {
        terminateShape();
        const CeiumPolygonClipA = new tileSetClipByPolygon({
          tileSet: tileset,
          originPositions: points,
          unionClippingRegions: false,
        });

        CeiumPolygonClipA.clippingByPositions();
        points = [];
        viewer.entities.removeAll();
      }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);
    </script>
  </body>
</html>
